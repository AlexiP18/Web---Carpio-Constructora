---
import { Icon } from "astro-icon/components";
import Button from "../../ui/Button.astro";
import OptimizedImage from "../../media/OptimizedImage.astro";

const logoCarpioConstructora = "/icons/LogoCarpioConstructora.svg";

const sliderImages = [
  {
    src: "https://res.cloudinary.com/dt5y4fsst/image/upload/w_1920,q_auto,f_auto/v1770001179/INDEX_Hero_Slider_1_g8gjt0.webp",
    alt: "Proyecto Constructora Carpio 1",
  },
  {
    src: "https://res.cloudinary.com/dt5y4fsst/image/upload/w_1920,q_auto,f_auto/v1770001180/INDEX_Hero_Slider_4_ydgvlr.webp",
    alt: "Proyecto Constructora Carpio 2",
  },
  {
    src: "https://res.cloudinary.com/dt5y4fsst/image/upload/w_1920,q_auto,f_auto/v1770001180/INDEX_Hero_Slider_3_tkaat7.webp",
    alt: "Proyecto Constructora Carpio 3",
  },
  {
    src: "https://res.cloudinary.com/dt5y4fsst/image/upload/w_1920,q_auto,f_auto/v1770001180/INDEX_Hero_Slider_2_fzeiig.webp",
    alt: "Proyecto Constructora Carpio 4",
  },
];
---

<section
  class="relative w-full min-h-screen flex items-center justify-center overflow-hidden"
  id="hero-slider"
>
  <!-- Background Slider Container -->
  <div
    class="absolute inset-0 w-full h-full bg-gray-900 bg-cover bg-center transition-all duration-700"
    style={`background-image: url('${sliderImages[0].src}')`}
  >
    <!-- WebGL Canvas for Liquid Transition -->
    <canvas
      id="hero-canvas"
      class="absolute inset-0 w-full h-full z-10 opacity-0 transition-opacity duration-1000"
    ></canvas>

    <!-- Hidden Images for Texture Loading (Visually hidden but rendered to ensure decoding) -->
    <div class="absolute w-0 h-0 opacity-0 pointer-events-none overflow-hidden">
      {
        sliderImages.map((image, index) => (
          <img
            src={image.src}
            alt={image.alt}
            id={`slide-img-${index}`}
            class="slider-source-image"
            crossorigin="anonymous"
          />
        ))
      }
    </div>
  </div>

  <!-- Enhanced Gradient Overlays -->
  <div
    class="absolute inset-0 bg-gradient-to-b from-black/30 via-black/40 to-black/70"
  >
  </div>
  <div
    class="absolute inset-0 bg-gradient-to-r from-black/30 via-transparent to-black/30"
  >
  </div>

  <!-- Slider Navigation Dots -->
  <div
    class="absolute bottom-20 left-1/2 transform -translate-x-1/2 flex space-x-3 z-20"
  >
    {
      sliderImages.map((_, index) => (
        <button
          class={`slider-dot w-3 h-3 rounded-full transition-all duration-300 ${index === 0 ? "bg-[#103646] scale-125" : "bg-white/50 hover:bg-[#103646]/75"}`}
          data-slide-to={index}
          aria-label={`Ir a imagen ${index + 1}`}
        />
      ))
    }
  </div>

  <!-- Centered Content Container following Figma layout -->
  <div
    class="relative z-10 w-full max-w-6xl mx-auto px-6 lg:px-8 text-center py-12 lg:py-16"
  >
    <div
      class="max-w-4xl mx-auto space-y-6"
      data-aos="fade-up"
      data-aos-duration="1200"
    >
      <!-- Main Heading - Logo SVG -->
      <div
        class="flex justify-center items-center mb-6"
        data-aos="fade-up"
        data-aos-duration="1200"
      >
        <img
          src={logoCarpioConstructora}
          alt="Constructora Carpio"
          class="h-20 sm:h-24 md:h-28 lg:h-32 xl:h-36 w-auto"
          style="filter: brightness(0) invert(1);"
        />
      </div>

      <!-- Subtitle - Figma specs: 20px font size -->
      <!-- <p class="font-heebo font-normal text-white/90 max-w-2xl mx-auto leading-relaxed"
         style="font-size: 20px; line-height: 1.6;">
        Construimos tus sueños con calidad y confianza. Proyectos residenciales y comerciales 
        con más de 15 años de experiencia en el sector.
      </p> -->

      <!-- Action Buttons - Using new standardized Button component -->
      <div
        class="flex flex-col sm:flex-row gap-4 justify-center items-center pt-4"
        data-aos="fade-up"
        data-aos-delay="300"
      >
        <Button
          href="/proyectos"
          variant="primary"
          size="lg"
          icon="ph:arrow-right"
          iconPosition="left"
          class="min-w-[180px] bg-[#103646] hover:bg-[#103646]/90 text-white border-[#103646]"
        >
          Ver Proyectos
        </Button>

        <Button
          href="/servicios"
          variant="outline"
          size="lg"
          icon="ph:list-bullets"
          iconPosition="left"
          class="min-w-[180px] border-white/40 text-white hover:bg-white hover:text-[#103646] backdrop-blur-sm"
        >
          Ver Servicios
        </Button>
      </div>
    </div>
  </div>

  <!-- Scroll Indicator -->
  <div
    class="absolute bottom-8 left-1/2 transform -translate-x-1/2 text-white animate-bounce"
    data-aos="fade-in"
    data-aos-delay="1200"
  >
    <Icon name="ph:arrow-down" class="w-6 h-6" />
  </div>
</section>

<style>
  /* Canvas z-index handling handled by class names */
  #hero-canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  /* Slider Dots Enhanced */
  .slider-dot {
    cursor: pointer;
    backdrop-filter: blur(4px);
    border: 2px solid rgba(255, 255, 255, 0.3);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .slider-dot.active {
    background: white !important;
    transform: scale(1.3) !important;
    border-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
  }

  .slider-dot:hover {
    transform: scale(1.1);
    border-color: rgba(255, 255, 255, 0.6);
  }

  /* Enhanced bounce effect */
  @media (prefers-reduced-motion: no-preference) {
    .animate-bounce {
      animation: enhancedBounce 2s infinite;
    }

    @keyframes enhancedBounce {
      0%,
      20%,
      53%,
      80%,
      100% {
        animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
        transform: translate3d(-50%, 0, 0);
      }
      40%,
      43% {
        animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
        transform: translate3d(-50%, -30px, 0);
      }
      70% {
        animation-timing-function: cubic-bezier(0.755, 0.05, 0.855, 0.06);
        transform: translate3d(-50%, -15px, 0);
      }
      90% {
        transform: translate3d(-50%, -4px, 0);
      }
    }
  }

  /* Enhanced text effects */
  h1 {
    text-shadow:
      2px 2px 8px rgba(0, 0, 0, 0.8),
      0 0 30px rgba(0, 0, 0, 0.6),
      0 0 20px rgba(255, 255, 255, 0.1);
    animation: textGlow 3s ease-in-out infinite alternate;
  }

  /* Better text readability */
  p {
    text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.7);
  }

  @keyframes textGlow {
    0% {
      text-shadow:
        2px 2px 4px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(255, 255, 255, 0.1);
    }
    100% {
      text-shadow:
        2px 2px 4px rgba(0, 0, 0, 0.7),
        0 0 30px rgba(255, 255, 255, 0.2);
    }
  }

  /* Improved responsive typography */
  @media (max-width: 640px) {
    h1 {
      font-size: clamp(36px, 10vw, 48px) !important;
    }

    .slider-dot {
      width: 12px;
      height: 12px;
    }
  }

  /* GPU acceleration */
  .slider-slide,
  .slider-bg {
    transform: translateZ(0);
    backface-visibility: hidden;
    will-change: transform, opacity;
  }
</style>

<script>
  // WebGL Shader Source
  const vertexShaderSource = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;

  // Standard Displacement Map Transition
  // Based on "aqua-light.jpg" reference type behavior
  const fragmentShaderSource = `
    precision mediump float;
    
    uniform sampler2D u_image0;
    uniform sampler2D u_image1;
    uniform sampler2D u_disp;   // Displacement Texture
    uniform float u_progress;
    uniform float u_intensity;
    
    varying vec2 v_texCoord;

    void main() {
      vec2 uv = v_texCoord;
      
      // Calculate Wave Intensity
      // "Llegaria hasta la mitad y despues se retraeria"
      // -> Distortion intensity goes 0.0 -> 1.0 (at 0.5) -> 0.0
      // Parabola: 4 * x * (1 - x) maps 0->1 to 0->1->0
      float intensity = 4.0 * u_progress * (1.0 - u_progress);
      
      // Sample Displacement Map
      // We can scroll the map slightly for movement feel
      vec2 dispUV = uv + vec2(0.0, u_progress * 0.2);
      vec4 dispColor = texture2D(u_disp, dispUV);
      
      // Calculate Displacement Vector
      // Red channel drives X, Green drives Y (or similar)
      // Reference often uses grayscale, so use R for both or R/G specific.
      // Let's use simple magnitude from Red.
      vec2 dispVec = vec2(dispColor.r, dispColor.r) * u_intensity * intensity * 0.5;
      
      // Apply Distortion to UVs
      vec2 uv0 = uv + dispVec;
      vec2 uv1 = uv - dispVec; // Inverse distortion for incoming? Or same?
      // Standard is usually: distort both towards center or verify specific style.
      // "Retracts": Intensity going to 0 handles "retracting" visual.
      
      vec4 t0 = texture2D(u_image0, uv0);
      vec4 t1 = texture2D(u_image1, uv1);
      
      // Crossfade
      gl_FragColor = mix(t0, t1, u_progress);
    }
  `;

  class HeroSlider {
    private currentSlide = 0;
    private totalSlides = 0;
    private autoPlayInterval: number | null = null;
    private transitionDuration = 6000;

    private canvas: HTMLCanvasElement | null = null;
    private gl: WebGLRenderingContext | null = null;
    private program: WebGLProgram | null = null;
    private textures: WebGLTexture[] = [];
    private dispTexture: WebGLTexture | null = null; // Displacement Texture
    private dots: HTMLElement[] = [];

    private isTransitioning = false;
    private progress = 0;
    private animationFrameId: number | null = null;
    private nextSlideIndex = 0;

    private lastScrollTime = 0;
    private scrollThreshold = 50;
    private scrollCooldown = 1200; // ms to wait before next scroll trigger

    // Loading state
    private loadedImagesCount = 0;
    private isDisplacementLoaded = false;

    constructor() {
      this.init();
    }

    private init(): void {
      console.log("HeroSlider init called");
      this.canvas = document.getElementById("hero-canvas") as HTMLCanvasElement;
      this.dots = Array.from(document.querySelectorAll(".slider-dot"));
      const images = document.querySelectorAll(".slider-source-image");

      this.totalSlides = images.length;

      if (!this.canvas || this.totalSlides === 0) return;

      this.initWebGL();

      // Load slide textures
      const imgElements = Array.from(images) as HTMLImageElement[];
      this.loadTextures(imgElements);

      // Load Displacement Map
      this.loadDisplacementMap("/displacement.png"); // We will create this

      this.draw(0, 0, 0);

      this.dots.forEach((dot, index) => {
        dot.addEventListener("click", () => this.goToSlide(index));
      });

      this.initSwipeSupport();
      this.startAutoPlay();

      this.startAutoPlay();

      window.addEventListener("resize", this.resize.bind(this));
      this.resize();
    }

    private resize() {
      if (!this.canvas || !this.gl) return;

      const displayWidth = this.canvas.clientWidth;
      const displayHeight = this.canvas.clientHeight;

      if (
        this.canvas.width !== displayWidth ||
        this.canvas.height !== displayHeight
      ) {
        this.canvas.width = displayWidth;
        this.canvas.height = displayHeight;
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        this.draw(this.currentSlide, this.nextSlideIndex, this.progress);
      }
    }

    private initWebGL() {
      if (!this.canvas) return;
      this.gl = this.canvas.getContext("webgl");
      if (!this.gl) return;

      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
      this.gl.clearColor(0.0, 0.0, 0.0, 0.0); // Transparent clear

      const vs = this.createShader(
        this.gl,
        this.gl.VERTEX_SHADER,
        vertexShaderSource,
      );
      const fs = this.createShader(
        this.gl,
        this.gl.FRAGMENT_SHADER,
        fragmentShaderSource,
      );
      if (!vs || !fs) return;

      this.program = this.createProgram(this.gl, vs, fs);
      if (!this.program) return;

      this.gl.useProgram(this.program);

      // Setup Quad
      const positionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
      this.gl.bufferData(
        this.gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
        this.gl.STATIC_DRAW,
      );

      const positionLocation = this.gl.getAttribLocation(
        this.program,
        "a_position",
      );
      this.gl.enableVertexAttribArray(positionLocation);
      this.gl.vertexAttribPointer(
        positionLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0,
      );

      const texCoordBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texCoordBuffer);
      this.gl.bufferData(
        this.gl.ARRAY_BUFFER,
        new Float32Array([0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0]),
        this.gl.STATIC_DRAW,
      );

      const texCoordLocation = this.gl.getAttribLocation(
        this.program,
        "a_texCoord",
      );
      this.gl.enableVertexAttribArray(texCoordLocation);
      this.gl.vertexAttribPointer(
        texCoordLocation,
        2,
        this.gl.FLOAT,
        false,
        0,
        0,
      );
    }

    private createShader(
      gl: WebGLRenderingContext,
      type: number,
      source: string,
    ) {
      const shader = gl.createShader(type);
      if (!shader) return null;
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    private createProgram(
      gl: WebGLRenderingContext,
      vs: WebGLShader,
      fs: WebGLShader,
    ) {
      const program = gl.createProgram();
      if (!program) return null;
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) return null;
      return program;
    }

    private loadTextures(images: HTMLImageElement[]): void {
      if (!this.gl) return;

      console.log("Loading textures...");
      images.forEach((img, idx) => {
        // Ensure image is loaded
        if (!img.complete) {
          console.warn(`Image ${idx} not loaded yet`);
          img.onload = () => this.loadSingleTexture(img, idx);
        } else {
          this.loadSingleTexture(img, idx);
        }
      });
    }

    private loadSingleTexture(img: HTMLImageElement, index: number) {
      if (!this.gl) return;
      const texture = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);

      this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_WRAP_S,
        this.gl.CLAMP_TO_EDGE,
      );
      this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_WRAP_T,
        this.gl.CLAMP_TO_EDGE,
      );
      this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_MIN_FILTER,
        this.gl.LINEAR,
      );
      this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_MAG_FILTER,
        this.gl.LINEAR,
      );

      this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.RGBA,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        img,
      );

      if (texture) {
        // Ensure textures array has correct size/order
        this.textures[index] = texture;
        console.log(`Texture ${index} loaded`);
        this.loadedImagesCount++;
        this.checkReady();
      }
    }

    private checkReady() {
      // Check if all images and displacement map are loaded
      if (
        this.loadedImagesCount === this.totalSlides &&
        this.isDisplacementLoaded &&
        this.canvas
      ) {
        console.log("All assets loaded. Revealing canvas.");
        // Initial draw to ensure content is there before revealing
        this.draw(this.currentSlide, this.currentSlide, 0);
        // Reveal canvas
        requestAnimationFrame(() => {
          this.canvas?.classList.remove("opacity-0");
        });
      }
    }

    private loadDisplacementMap(url: string) {
      if (!this.gl) return;
      const img = new Image();
      img.src = url;
      img.onload = () => {
        const texture = this.gl!.createTexture();
        this.gl!.bindTexture(this.gl!.TEXTURE_2D, texture);
        this.gl!.texParameteri(
          this.gl!.TEXTURE_2D,
          this.gl!.TEXTURE_WRAP_S,
          this.gl!.CLAMP_TO_EDGE,
        );
        this.gl!.texParameteri(
          this.gl!.TEXTURE_2D,
          this.gl!.TEXTURE_WRAP_T,
          this.gl!.CLAMP_TO_EDGE,
        );
        this.gl!.texParameteri(
          this.gl!.TEXTURE_2D,
          this.gl!.TEXTURE_MIN_FILTER,
          this.gl!.LINEAR,
        );
        this.gl!.texParameteri(
          this.gl!.TEXTURE_2D,
          this.gl!.TEXTURE_MAG_FILTER,
          this.gl!.LINEAR,
        );
        this.gl!.texImage2D(
          this.gl!.TEXTURE_2D,
          0,
          this.gl!.RGBA,
          this.gl!.RGBA,
          this.gl!.UNSIGNED_BYTE,
          img,
        );
        this.dispTexture = texture;
        this.isDisplacementLoaded = true;
        console.log("Displacement map loaded");
        this.checkReady();
      };

      // Fallback if displacement fails
      img.onerror = () => {
        console.warn("Displacement map failed to load. Proceeding without it.");
        this.isDisplacementLoaded = true; // Pretend it loaded to unblock
        this.checkReady();
      };
    }

    private draw(slideIndex0: number, slideIndex1: number, progress: number) {
      if (!this.gl || !this.program) return;

      this.gl.useProgram(this.program);

      const u_image0 = this.gl.getUniformLocation(this.program, "u_image0");
      const u_image1 = this.gl.getUniformLocation(this.program, "u_image1");
      const u_disp = this.gl.getUniformLocation(this.program, "u_disp");
      const u_progress = this.gl.getUniformLocation(this.program, "u_progress");
      const u_intensity = this.gl.getUniformLocation(
        this.program,
        "u_intensity",
      );

      this.gl.uniform1i(u_image0, 0);
      this.gl.uniform1i(u_image1, 1);
      this.gl.uniform1i(u_disp, 2);
      this.gl.uniform1f(u_progress, progress);
      // Soften intensity from 0.4 to 0.15 for a smoother, less "exaggerated" look
      this.gl.uniform1f(u_intensity, 0.15);

      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[slideIndex0]);

      this.gl.activeTexture(this.gl.TEXTURE1);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[slideIndex1]);

      if (this.dispTexture) {
        this.gl.activeTexture(this.gl.TEXTURE2);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.dispTexture);
      }

      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }

    private animateTransition(): void {
      if (!this.isTransitioning) return;

      this.progress += 0.015; // Animation speed
      // console.log("Animation progress:", this.progress);

      if (this.progress >= 1) {
        this.progress = 0;
        this.isTransitioning = false;
        this.currentSlide = this.nextSlideIndex;
        // Draw final state cleanly
        this.draw(this.currentSlide, this.currentSlide, 0);
        return;
      }

      this.draw(this.currentSlide, this.nextSlideIndex, this.progress);
      this.animationFrameId = requestAnimationFrame(
        this.animateTransition.bind(this),
      );
    }

    private updateSlider(newIndex: number): void {
      console.log(
        `Update slider to ${newIndex}. Current: ${this.currentSlide}. Transitioning: ${this.isTransitioning}`,
      );
      if (this.isTransitioning || newIndex === this.currentSlide) return;

      this.nextSlideIndex = newIndex;
      this.isTransitioning = true;
      this.progress = 0;

      // Update dots
      this.dots.forEach((dot, index) => {
        dot.classList.toggle("active", index === newIndex);
      });

      this.animateTransition();
    }

    private goToSlide(index: number) {
      this.stopAutoPlay();
      this.updateSlider(index);
      this.startAutoPlay();
    }

    private nextSlide() {
      const nextIndex = (this.currentSlide + 1) % this.totalSlides;
      this.updateSlider(nextIndex);
    }

    private prevSlide(): void {
      const prevIndex =
        (this.currentSlide - 1 + this.totalSlides) % this.totalSlides;
      this.goToSlide(prevIndex);
    }

    private startAutoPlay(): void {
      this.stopAutoPlay();
      this.autoPlayInterval = window.setInterval(() => {
        this.nextSlide();
      }, this.transitionDuration);
    }

    private stopAutoPlay(): void {
      if (this.autoPlayInterval) {
        clearInterval(this.autoPlayInterval);
        this.autoPlayInterval = null;
      }
    }

    private initSwipeSupport(): void {
      let startX = 0;
      let startY = 0;
      let endX = 0;
      let endY = 0;

      const element = this.canvas || document.getElementById("hero-slider");
      if (!element) return;

      element.addEventListener(
        "touchstart",
        (e) => {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        },
        { passive: true },
      );

      element.addEventListener(
        "touchend",
        (e) => {
          endX = e.changedTouches[0].clientX;
          endY = e.changedTouches[0].clientY;

          const deltaX = endX - startX;
          const deltaY = endY - startY;

          // Only trigger if horizontal swipe is dominant
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
            if (deltaX > 0) {
              this.prevSlide();
            } else {
              this.nextSlide();
            }
          }
        },
        { passive: true },
      );
    }
    public destroy(): void {
      this.stopAutoPlay();
      if (this.animationFrameId) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.isTransitioning = false;

      // Remove event listeners if stored... (simplification: just stopping loops is enough for now)
      // Ideally we should remove resize listener too.
      window.removeEventListener("resize", this.resize.bind(this)); // Wait, bind creates new function reference.
      // To properly remove, we need to store the bound function.
    }
  }

  // Enhanced Intersection Observer for animations
  const observerOptions: IntersectionObserverInit = {
    threshold: 0.1,
    rootMargin: "0px 0px -50px 0px",
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        (entry.target as HTMLElement).classList.add("animate-in");
      }
    });
  }, observerOptions);

  // Singleton instance
  let heroSliderInstance: HeroSlider | null = null;

  // Initialize slider
  function initHeroSlider() {
    try {
      if (heroSliderInstance) {
        console.log("HeroSlider already initialized. Destroying old instance.");
        heroSliderInstance.destroy();
        heroSliderInstance = null;
      }

      console.log("Initializing Hero Slider...");
      heroSliderInstance = new HeroSlider();

      // Observe elements for animations
      document.querySelectorAll("[data-aos]").forEach((el) => {
        observer.observe(el);
      });
    } catch (error) {
      console.error("Error initializing Hero Slider:", error);
    }
  }

  // Single robust initialization point
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initHeroSlider);
  } else {
    // Run immediately if ready
    initHeroSlider();
  }
</script>
